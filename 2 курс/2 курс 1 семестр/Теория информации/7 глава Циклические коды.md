# 1. Основные понятия линейного кодирования
*   **Линейный код:** Код, в котором любая разрешенная (допустимая) кодовая комбинация является линейной комбинацией других разрешенных комбинаций. Для двоичных кодов операция сложения — это сложение по модулю 2 (XOR).
*   **Параметры кода:** Обозначается как `(n, k)`-код.
    *   `n` — общая длина кодового слова (всего битов).
    *   `k` — число информационных битов (`nи`).
    *   `r = n - k` — число проверочных (избыточных) битов (`nк`).
*   **Свойство:** Сумма (разность) любых двух кодовых векторов линейного кода также является кодовым вектором этого кода.
*   **Минимальное кодовое расстояние (`d₀`):** Наименьшее расстояние Хэмминга между любыми двумя различными разрешенными кодовыми словами. Это ключевой параметр, определяющий корректирующую способность кода.
    *   Исправление всех ошибок кратности до `s`: `d₀ >= 2s + 1`.
    *   Обнаружение всех ошибок кратности до `r`: `d₀ >= r + 1`.

---
# 2. Построение линейных кодов с помощью матриц
Линейный код можно задать с помощью **порождающей матрицы** `G` или **проверочной матрицы** `H`.
*   **Порождающая матрица `G` (размером `k x n`):**
    *   Строки матрицы `G` представляют собой `k` линейно независимых кодовых слов.
    *   Любое кодовое слово `A` получается умножением информационного вектора `U` на матрицу `G`: `A = U * G`.
    *   В канонической форме матрица `G` имеет вид `G = [I_k | P]`, где `I_k` — единичная матрица размером `k x k`, а `P` — матрица проверки размером `k x r`. Это означает, что информационные биты остаются неизменными, а проверочные биты вычисляются по ним.
*   **Проверочная матрица `H` (размером `r x n`):**
    *   Используется для проверки принадлежности принятого вектора `F` к коду. Если `F` — правильное кодовое слово, то `F * H^T = 0` (где `H^T` — транспонированная матрица `H`).
    *   В канонической форме матрица `H` имеет вид `H = [P^T | I_r]`, где `I_r` — единичная матрица размером `r x r`.
    *   Связь между `G` и `H`: `G * H^T = 0`.
---
# 3. Процесс кодирования и декодирования
*   **Кодирование:**
    1.  Информационный вектор `U` (длины `k`) умножается на порождающую матрицу `G` (размером `k x n`), в результате получается полное кодовое слово `A` (длины `n`): `A = U * G`.
    2.  Для систематических кодов (каноническая форма `G`) информационные биты находятся в начале, а проверочные — в конце кодового слова.
*   **Декодирование (обнаружение и исправление ошибок):**
    1.  Принятое слово `F` (возможно, с ошибками) умножается на транспонированную проверочную матрицу `H^T`: `S = F * H^T`.
    2.  Полученный вектор `S` называется **синдромом**.
        *   Если `S = 0`, то ошибок нет (или они не обнаружены).
        *   Если `S ≠ 0`, то ошибки есть. Вектор `S` указывает на характер и местоположение ошибки.
    3.  По синдрому `S` находится вектор ошибки `e` (например, с помощью таблицы синдромов или алгоритмически).
    4.  Исправленное кодовое слово `A` вычисляется как `A = F ⊕ e` (сложение по модулю 2).
---
# 4. Код Хэмминга
Код Хэмминга — это класс линейных блоковых кодов, предназначенный для исправления одиночных ошибок (`d₀ = 3`).
*   **Основные характеристики:**
    *   Минимальное кодовое расстояние `d₀ = 3`.
    *   Может исправлять все одиночные ошибки (`s = 1`).
    *   Может обнаруживать все двойные ошибки (`r = 2`).
*   **Расчет числа проверочных разрядов:**
    *   Для кода, исправляющего одиночные ошибки, число проверочных разрядов `k` должно удовлетворять условию: `2^k >= n + 1`, где `n = k + m` — общая длина кода, `m` — число информационных разрядов.
    *   Формулы для расчета:
        *   Если известна общая длина `n`: `k = ⌈log₂(n + 1)⌉`.
        *   Если известно число информационных разрядов `m`: `k = ⌈log₂((m + 1) + ⌈log₂(m + 1)⌉)⌉`.
*   **Построение кода Хэмминга:**
    1.  Проверочные биты располагаются на позициях, соответствующих степеням двойки (1, 2, 4, 8, ...).
    2.  Каждый проверочный бит рассчитывается так, чтобы обеспечить четность (или нечетность) определенной группы битов. Группа формируется следующим образом: проверочный бит на позиции `2^i` контролирует все биты, номера которых в двоичном представлении содержат единицу в `i`-й позиции.
    3.  При приеме кодовой комбинации производится проверка на четность для каждой группы, контролируемой проверочным битом. Результаты проверок образуют **синдром**.
    4.  **Исправление ошибки:** Значение синдрома (в двоичной системе) указывает номер позиции, в которой произошла ошибка. Например, если синдром равен `011` (что равно 3 в десятичной системе), значит, ошибка в 3-м бите. Этот бит инвертируется для исправления ошибки.
*   **Пример (7-битовый код Хэмминга):**
    *   Длина кода `n = 7`, число информационных битов `m = 4`, число проверочных битов `k = 3`.
    *   Проверочные биты находятся на позициях 1, 2, 4.
    *   Проверка на четность:
        *   Бит 1 (p1) контролирует позиции 1, 3, 5, 7.
        *   Бит 2 (p2) контролирует позиции 2, 3, 6, 7.
        *   Бит 4 (p4) контролирует позиции 4, 5, 6, 7.
    *   Если при приеме синдром равен `011`, ошибка в бите 3.
---
# 5. Таблица синдромов и декодирование
Для декодирования используется **таблица синдромов**.
*   **Структура таблицы:**
    *   Строки таблицы соответствуют всем возможным векторам ошибок `e_j` (включая нулевой вектор).
    *   Столбцы соответствуют всем разрешенным кодовым словам `A_i`.
    *   На пересечении строки `e_j` и столбца `A_i` находится вектор `e_j ⊕ A_i`, который представляет собой кодовое слово, искаженное ошибкой `e_j`.
*   **Процесс декодирования:**
    1.  Вычисляется синдром `S` для принятого вектора `F`.
    2.  Находится строка в таблице, соответствующая этому синдрому.
    3.  В этой строке отыскивается вектор, совпадающий с принятым `F`.
    4.  Номер столбца, в котором найден этот вектор, указывает на исходное (правильное) кодовое слово `A_i`.
    5.  Вектор ошибки `e_j` находится по номеру строки. Исправленное слово `A = F ⊕ e_j`.
---
# 6. Границы кодирования
Для оценки эффективности кодов существуют теоретические границы.
*   **Граница Хэмминга:** Устанавливает верхнюю границу для числа информационных битов `k` при заданной длине кода `n` и минимальном расстоянии `d₀`. Для кодов, исправляющих `t` ошибок, она имеет вид: `∑(i=0 to t) C_n^i <= 2^(n-k)`.
*   **Граница Плоткина:** Также устанавливает верхнюю границу для минимального расстояния `d₀` при заданных `n` и `k`. Для двоичных кодов: `d₀ <= n * 2^(k-1) / (2^k - 1)`.
---
# 7. Классификация помехоустойчивых кодов
Помехоустойчивые коды можно классифицировать по нескольким признакам:
*   **По структуре:**
    *   **Блоковые коды:** Кодируются блоки фиксированной длины. Кодер не имеет памяти.
    *   **Древовидные (сверточные) коды:** Кодируются последовательности, кодер имеет память.
*   **По типу исправляемых ошибок:**
    *   **Исправляющие случайные ошибки:** Предназначены для исправления независимых ошибок, возникающих в разных битах.
    *   **Исправляющие пакеты ошибок:** Предназначены для исправления групп ошибок, идущих подряд (пакетов). Часто используются в сочетании с устройствами перемежения (interleavers) для "размазывания" пакетов ошибок в случайные.

---
# 8. Практическое применение
Линейные коды, особенно код Хэмминга, широко применяются в различных областях:
*   **Хранение данных:** В оперативной памяти (RAM) и жестких дисках (HDD/SSD) для обнаружения и исправления ошибок чтения/записи.
*   **Передача данных:** В компьютерных сетях (Ethernet, Wi-Fi) и спутниковой связи для повышения надежности передачи.
*   **Телекоммуникации:** В мобильной связи (GSM, LTE) для защиты голосовых и текстовых сообщений от помех.

1 Пом уст коды и методики их применения
2 Лин коды их пар и свойства  ос блочного кода хэвинга
3 Опред и св дв циклических кодов, обнаружение пакетов ошибок

# 1 Пом уст коды и методики их применения
Про б